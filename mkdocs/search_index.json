{
    "docs": [
        {
            "location": "/",
            "text": "zend-router\n\n\n\n\n\n\nzend-router provides flexible HTTP and console routing.\n\n\nHTTP-based routing currently works against the\n\nzend-http\n request and responses,\nand provides capabilities around:\n\n\n\n\nLiteral path matches\n\n\nPath segment matches (at path boundaries, and optionally validated using regex)\n\n\nRegular expression path matches\n\n\nHTTP request scheme\n\n\nHTTP request method\n\n\nHostname\n\n\n\n\nAdditionally, it supports combinations of different route types in tree\nstructures, allowing for fast, b-tree lookups.\n\n\nConsole routing leverages \nzend-console's routing capabilities\n,\nproviding a unified mechanism for working with routes regardless of the\nenviornment.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-router/issues\n\n\nDocumentation is at https://zendframework.github.io/zend-router/",
            "title": "Home"
        },
        {
            "location": "/#zend-router",
            "text": "zend-router provides flexible HTTP and console routing.  HTTP-based routing currently works against the zend-http  request and responses,\nand provides capabilities around:   Literal path matches  Path segment matches (at path boundaries, and optionally validated using regex)  Regular expression path matches  HTTP request scheme  HTTP request method  Hostname   Additionally, it supports combinations of different route types in tree\nstructures, allowing for fast, b-tree lookups.  Console routing leverages  zend-console's routing capabilities ,\nproviding a unified mechanism for working with routes regardless of the\nenviornment.   File issues at https://github.com/zendframework/zend-router/issues  Documentation is at https://zendframework.github.io/zend-router/",
            "title": "zend-router"
        },
        {
            "location": "/routing/",
            "text": "Routing\n\n\nRouting is the act of matching a request to a given controller.\n\n\nTypically, routing will examine the request URI, and attempt to match the URI\npath segment against provided constraints. If the constraints match, a set of\n\"matches\" are returned, one of which should be the controller name to execute.\nRouting can utilize other portions of the request URI or environment as well.\nFor example, the host or scheme, query parameters, headers, request method, and\nmore.\n\n\nThe base unit of routing is a \nRoute\n:\n\n\nnamespace Zend\\Mvc\\Router;\n\nuse Zend\\Stdlib\\RequestInterface as Request;\n\ninterface RouteInterface\n{\n    public static function factory(array $options = []);\n    public function match(Request $request);\n    public function assemble(array $params = [], array $options = []);\n}\n\n\n\n\nA \nRoute\n accepts a \nRequest\n, and determines if it matches. If so, it returns a\n\nRouteMatch\n object:\n\n\nnamespace Zend\\Mvc\\Router;\n\nclass RouteMatch\n{\n    public function __construct(array $params);\n    public function setMatchedRouteName($name);\n    public function getMatchedRouteName();\n    public function setParam($name, $value);\n    public function getParams();\n    public function getParam($name, $default = null);\n}\n\n\n\n\nTypically, when a \nRoute\n matches, it will define one or more parameters. These\nare passed into the \nRouteMatch\n, and objects may query the \nRouteMatch\n for\ntheir values.\n\n\n$id = $routeMatch-\ngetParam('id', false);\nif (! $id) {\n    throw new Exception('Required identifier is missing!');\n}\n$entity = $resource-\nget($id);\n\n\n\n\nUsually you will have multiple routes you wish to test against. In order to\nfacilitate this, you will use a route aggregate, usually implementing\n\nRouteStack\n:\n\n\nnamespace Zend\\Mvc\\Router;\n\ninterface RouteStackInterface extends RouteInterface\n{\n    public function addRoute($name, $route, $priority = null);\n    public function addRoutes(array $routes);\n    public function removeRoute($name);\n    public function setRoutes(array $routes);\n}\n\n\n\n\nRoutes will be queried in a LIFO order, and hence the reason behind the name\n\nRouteStack\n. zend-mvc provides two implementations of this interface,\n\nSimpleRouteStack\n and \nTreeRouteStack\n. In each, you register routes either one\nat a time using \naddRoute()\n, or in bulk using \naddRoutes()\n.\n\n\n// One at a time:\n$route = Literal::factory([\n    'route' =\n '/foo',\n    'defaults' =\n [\n        'controller' =\n 'foo-index',\n        'action'     =\n 'index',\n    ],\n]);\n$router-\naddRoute('foo', $route);\n\n// In bulk:\n$router-\naddRoutes([\n    // using already instantiated routes:\n    'foo' =\n $route,\n\n    // providing configuration to allow lazy-loading routes:\n    'bar' =\n [\n        'type' =\n 'literal',\n        'options' =\n [\n            'route' =\n '/bar',\n            'defaults' =\n [\n                'controller' =\n 'bar-index',\n                'action'     =\n 'index',\n            ],\n        ],\n    ],\n]);\n\n\n\n\nRouter Types\n\n\nTwo routers are provided, the \nSimpleRouteStack\n and \nTreeRouteStack\n. Each\nworks with the above interface, but utilize slightly different options and\nexecution paths. By default, the zend-mvc uses the \nTreeRouteStack\n as the\nrouter.\n\n\nSimpleRouteStack\n\n\nThis router takes individual routes that provide their full matching logic in\none go, and loops through them in LIFO order until a match is found. As such,\nroutes that will match most often should be registered last, and least common\nroutes first. Additionally, you will need to ensure that routes that potentially\noverlap are registered such that the most specific match will match first (i.e.,\nregister later). Alternatively, you can set priorities by giving the priority as\nthird parameter to the \naddRoute()\n method, specifying the priority in the route\nspecifications or setting the priority property within a route instance before\nadding it to the route stack.\n\n\nTreeRouteStack\n\n\nZend\\Mvc\\Router\\Http\\TreeRouteStack\n provides the ability to register trees of\nroutes, and uses a B-tree algorithm to match routes. As such, you register a\nsingle route with many children.\n\n\nA \nTreeRouteStack\n will consist of the following configuration:\n\n\n\n\nA base \"route\", which describes the base match needed, the root of the tree.\n\n\nAn optional \nroute_plugins\n, which is a configured\n  \nZend\\Mvc\\Router\\RoutePluginManager\n that can lazy-load routes.\n\n\nThe option \nmay_terminate\n, which hints to the router that no other segments\n  will follow it.\n\n\nAn optional \nchild_routes\n array, which contains additional routes that stem\n  from the base \"route\" (i.e., build from it). Each child route can itself be a\n  \nTreeRouteStack\n if desired; in fact, the \nPart\n route works exactly this way.\n\n\n\n\nWhen a route matches against a \nTreeRouteStack\n, the matched parameters from\neach segment of the tree will be returned.\n\n\nA \nTreeRouteStack\n can be your sole route for your application, or describe\nparticular path segments of the application.\n\n\nAn example of a \nTreeRouteStack\n is provided in the documentation of the \nPart\n\nroute.\n\n\nHTTP Route Types\n\n\nzend-mvc ships with the following HTTP route types.\n\n\nZend\\Mvc\\Router\\Http\\Hostname\n\n\nThe \nHostname\n route attempts to match the hostname registered in the request\nagainst specific criteria. Typically, this will be in one of the following\nforms:\n\n\n\n\nsubdomain.domain.tld\n\n\n:subdomain.domain.tld\n\n\n\n\nIn the above, the second route would return a \"subdomain\" key as part of the\nroute match.\n\n\nFor any given hostname segment, you may also provide a constraint. As an\nexample, if the \"subdomain\" segment needed to match only if it started with \"fw\"\nand contained exactly 2 digits following, the following route would be needed:\n\n\n$route = Hostname::factory([\n    'route' =\n ':subdomain.domain.tld',\n    'constraints' =\n [\n        'subdomain' =\n 'fw\\d{2}',\n    ],\n]);\n\n\n\n\nIn the above example, only a \"subdomain\" key will be returned in the\n\nRouteMatch\n. If you wanted to also provide other information based on matching,\nor a default value to return for the subdomain, you need to also provide\ndefaults.\n\n\n$route = Hostname::factory([\n    'route' =\n ':subdomain.domain.tld',\n    'constraints' =\n [\n        'subdomain' =\n 'fw\\d{2}',\n    ],\n    'defaults' =\n [\n        'type' =\n 'json',\n    ],\n]);\n\n\n\n\nWhen matched, the above will return two keys in the \nRouteMatch\n, \"subdomain\"\nand \"type\".\n\n\nZend\\Mvc\\Router\\Http\\Literal\n\n\nThe \nLiteral\n route is for doing exact matching of the URI path. Configuration\ntherefore is solely the path you want to match, and the \"defaults\", or\nparameters you want returned on a match.\n\n\n$route = Literal::factory([\n    'route' =\n '/foo',\n    'defaults' =\n [\n        'controller' =\n 'Application\\Controller\\IndexController',\n        'action' =\n 'foo',\n    ],\n]);\n\n\n\n\nThe above route would match a path \"/foo\", and return the key \"action\" in the\n\nRouteMatch\n, with the value \"foo\".\n\n\nZend\\Mvc\\Router\\Http\\Method\n\n\nThe \nMethod\n route is used to match the HTTP method or 'verb' specified in the\nrequest (See RFC 2616 Sec. 5.1.1). It can optionally be configured to match\nagainst multiple methods by providing a comma-separated list of method tokens.\n\n\n$route = Method::factory([\n    'verb' =\n 'post,put',\n    'defaults' =\n [\n        'controller' =\n 'Application\\Controller\\IndexController',\n        'action' =\n 'form-submit',\n    ],\n]);\n\n\n\n\nThe above route would match an http \"POST\" or \"PUT\" request and return a\n\nRouteMatch\n object containing a key \"action\" with a value of \"form-submit\".\n\n\nZend\\Mvc\\Router\\Http\\Part\n\n\nA \nPart\n route allows crafting a tree of possible routes based on segments of\nthe URI path. It actually extends the \nTreeRouteStack\n.\n\n\nPart\n routes are difficult to describe, so we'll simply provide a sample one\nhere.\n\n\n$route = Part::factory([\n    'route' =\n [\n        'type' =\n 'literal',\n        'options' =\n [\n            'route' =\n '/',\n            'defaults' =\n [\n                'controller' =\n 'Application\\Controller\\IndexController',\n                'action' =\n 'index',\n            ],\n        ],\n    ],\n    'route_plugins' =\n $routePlugins,\n    'may_terminate' =\n true,\n    'child_routes' =\n [\n        'blog' =\n [\n            'type' =\n 'literal',\n            'options' =\n [\n                'route' =\n '/blog',\n                'defaults' =\n [\n                    'controller' =\n 'Application\\Controller\\BlogController',\n                    'action' =\n 'index',\n                ],\n            ],\n            'may_terminate' =\n true,\n            'child_routes' =\n [\n                'rss' =\n [\n                    'type' =\n 'literal',\n                    'options' =\n [\n                        'route' =\n '/rss',\n                        'defaults' =\n [\n                            'action' =\n 'rss',\n                        ]\n                    ],\n                    'may_terminate' =\n true,\n                    'child_routes' =\n [\n                        'subrss' =\n [\n                            'type' =\n 'literal',\n                            'options' =\n [\n                                'route' =\n '/sub',\n                                'defaults' =\n [\n                                    'action' =\n 'subrss',\n                                ],\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n        'forum' =\n [\n            'type' =\n 'literal',\n            'options' =\n [\n                'route' =\n 'forum',\n                'defaults' =\n [\n                    'controller' =\n 'Application\\Controller\\ForumController',\n                    'action' =\n 'index',\n                ],\n            ],\n        ],\n    ],\n]);\n\n\n\n\nThe above would match the following:\n\n\n\n\n/\n would load the \"Index\" controller, \"index\" action.\n\n\n/blog\n would load the \"Blog\" controller, \"index\" action.\n\n\n/blog/rss\n would load the \"Blog\" controller, \"rss\" action.\n\n\n/blog/rss/sub\n would load the \"Blog\" controller, \"subrss\" action.\n\n\n/forum\n would load the \"Forum\" controller, \"index\" action.\n\n\n\n\nYou may use any route type as a child route of a \nPart\n route.\n\n\n\n\nPart routes are an implementation detail\n\n\nPart\n routes are not meant to be used directly. When you add definitions for\n\nchild_routes\n to any route type, that route will become a \nPart\n route. As\nalready said, describing \nPart\n routes with words is difficult, so hopefully\nthe additional \nexamples at the end\n will provide\nfurther insight.\n\n\nRoute plugins\n\n\nIn the above example, the \n$routePlugins\n is an instance of\n\nZend\\Mvc\\Router\\RoutePluginManager\n, containing essentially the following\nconfiguration:\n\n\n$routePlugins = new Zend\\Mvc\\Router\\RoutePluginManager();\n$plugins = [\n    'hostname' =\n 'Zend\\Mvc\\Router\\Http\\Hostname',\n    'literal'  =\n 'Zend\\Mvc\\Router\\Http\\Literal',\n    'part'     =\n 'Zend\\Mvc\\Router\\Http\\Part',\n    'regex'    =\n 'Zend\\Mvc\\Router\\Http\\Regex',\n    'scheme'   =\n 'Zend\\Mvc\\Router\\Http\\Scheme',\n    'segment'  =\n 'Zend\\Mvc\\Router\\Http\\Segment',\n    'wildcard' =\n 'Zend\\Mvc\\Router\\Http\\Wildcard',\n    'query'    =\n 'Zend\\Mvc\\Router\\Http\\Query',\n    'method'   =\n 'Zend\\Mvc\\Router\\Http\\Method',\n];\nforeach ($plugins as $name =\n $class) {\n    $routePlugins-\nsetInvokableClass($name, $class);\n}\n\n\n\n\nWhen using \nZend\\Mvc\\Router\\Http\\TreeRouteStack\n, the \nRoutePluginManager\n is\nset up by default, and the developer does not need to worry about autoloading\nof standard HTTP routes.\n\n\n\n\nZend\\Mvc\\Router\\Http\\Regex\n\n\nA \nRegex\n route utilizes a regular expression to match against the URI path. Any\nvalid regular expression is allowed; our recommendation is to use named captures\nfor any values you want to return in the \nRouteMatch\n.\n\n\nSince regular expression routes are often complex, you must specify a \"spec\" or\nspecification to use when assembling URLs from regex routes. The spec is simply\na string; replacements are identified using \n%keyname%\n within the string, with\nthe keys coming from either the captured values or named parameters passed to\nthe \nassemble()\n method.\n\n\nJust like other routes, the \nRegex\n route can accept \"defaults\", parameters to\ninclude in the \nRouteMatch\n when successfully matched.\n\n\n$route = Regex::factory([\n    'regex' =\n '/blog/(?\nid\n[a-zA-Z0-9_-]+)(\\.(?\nformat\n(json|html|xml|rss)))?',\n    'defaults' =\n [\n        'controller' =\n 'Application\\Controller\\BlogController',\n        'action'     =\n 'view',\n        'format'     =\n 'html',\n    ],\n    'spec' =\n '/blog/%id%.%format%',\n]);\n\n\n\n\nThe above would match \n/blog/001-some-blog_slug-here.html\n, and return four\nitems in the \nRouteMatch\n, an \"id\", the \"controller\", the \"action\", and the\n\"format\". When assembling a URL from this route, the \"id\" and \"format\" values\nwould be used to fill the specification.\n\n\nZend\\Mvc\\Router\\Http\\Scheme\n\n\nThe \nScheme\n route matches the URI scheme only, and must be an exact match. As\nsuch, this route, like the \nLiteral\n route, simply takes what you want to match\nand the \"defaults\", parameters to return on a match.\n\n\n$route = Scheme::factory([\n    'scheme' =\n 'https',\n    'defaults' =\n [\n        'https' =\n true,\n    ],\n]);\n\n\n\n\nThe above route would match the \"https\" scheme, and return the key \"https\" in\nthe \nRouteMatch\n with a boolean \ntrue\n value.\n\n\nZend\\Mvc\\Router\\Http\\Segment\n\n\nA \nSegment\n route allows matching any segment of a URI path. Segments are\ndenoted using a colon, followed by alphanumeric characters; if a segment is\noptional, it should be surrounded by brackets.  As an example, \n/:foo[/:bar]\n\nwould match a \n/\n followed by text and assign it to the key \"foo\"; if any\nadditional \n/\n characters are found, any text following the last one will be\nassigned to the key \"bar\".\n\n\nThe separation between literal and named segments can be anything. For example,\nthe above could be done as \n/:foo{-}[-:bar]\n as well. The \n{-}\n after the \n:foo\n\nparameter indicates a set of one or more delimiters, after which matching of the\nparameter itself ends.\n\n\nEach segment may have constraints associated with it. Each constraint should\nsimply be a regular expression expressing the conditions under which that\nsegment should match.\n\n\nAlso, as you can in other routes, you may provide defaults to use; these are\nparticularly useful when using optional segments.\n\n\nAs a complex example:\n\n\n$route = Segment::factory([\n    'route' =\n '/:controller[/:action]',\n    'constraints' =\n [\n        'controller' =\n '[a-zA-Z][a-zA-Z0-9_-]+',\n        'action'     =\n '[a-zA-Z][a-zA-Z0-9_-]+',\n    ],\n    'defaults' =\n [\n        'controller' =\n 'Application\\Controller\\IndexController',\n        'action'     =\n 'index',\n    ],\n]);\n\n\n\n\nZend\\Mvc\\Router\\Http\\Query (Deprecated)\n\n\n\n\nPotential security issue\n\n\nMisuse of this route can lead to potential security issues.\n\n\nDeprecated\n\n\nThis route part is deprecated since you can now add query parameters without a\nquery route.\n\n\n\n\nThe \nQuery\n route part allows you to specify and capture query string parameters\nfor a given route.\n\n\nThe intention of the \nQuery\n part is that you do not instantiate it in its own\nright, but use it as a child of another route part.\n\n\nAn example of its usage would be:\n\n\n$route = Part::factory([\n    'route' =\n [\n        'type'    =\n 'literal',\n        'options' =\n [\n            'route'    =\n 'page',\n            'defaults' =\n [],\n        ],\n    ],\n    'may_terminate' =\n true,\n    'route_plugins' =\n $routePlugins,\n    'child_routes'  =\n [\n        'query' =\n [\n            'type' =\n 'Query',\n            'options' =\n [\n                'defaults' =\n [\n                    'foo' =\n 'bar',\n                ],\n            ],\n        ],\n    ],\n]);\n\n\n\n\nThis then allows you to create query strings using the url view helper.\n\n\n$this-\nurl(\n    'page/query',\n    [\n        'name'   =\n 'my-test-page',\n        'format' =\n 'rss',\n        'limit'  =\n 10,\n    ]\n);\n\n\n\n\nPer the above example, you must add \n/query\n (the name we gave to our query\nroute segment) to your route name in order to append a query string. If you do\nnot specify \n/query\n in the route name, then no query string will be appended.\n\n\nOur example \"page\" route has only one defined parameter of \"name\"\n(\n/page[/:name]\n), meaning that the remaining parameters of \"format\" and \"limit\"\nwill then be appended as a query string.\n\n\nThe output from our example should then be\n\n/page/my-test-page?format=rss\nlimit=10\n\n\nZend\\Mvc\\Router\\Http\\Wildcard (Deprecated)\n\n\n\n\nPotential security issue\n\n\nMisuse of this route type can lead to potential security issues.\n\n\nDeprecated\n\n\nThis route type is deprecated. Use the \nSegment\n route type.\n\n\n\n\nThe \nWildcard\n route type matches all remaining segments of a URI path.\n\n\nHTTP Routing Examples\n\n\nMost of the routing definitions will be done in module configuration files, so\nthe following examples will show how to set up routes in config files.\n\n\nSimple example with two literal routes\n\n\nreturn [\n    'router' =\n [\n        'routes' =\n [\n            // Literal route named \nhome\n\n            'home' =\n [\n                'type' =\n 'literal',\n                'options' =\n [\n                    'route' =\n '/',\n                    'defaults' =\n [\n                        'controller' =\n 'Application\\Controller\\IndexController',\n                        'action' =\n 'index',\n                    ],\n                ],\n            ],\n            // Literal route named \ncontact\n\n            'contact' =\n [\n                'type' =\n 'literal',\n                'options' =\n [\n                    'route' =\n 'contact',\n                    'defaults' =\n [\n                        'controller' =\n 'Application\\Controller\\ContactController',\n                        'action' =\n 'form',\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\nA complex example with child routes\n\n\nreturn [\n    'router' =\n [\n        'routes' =\n [\n            // Literal route named \nhome\n\n            'home' =\n [\n                'type' =\n 'literal',\n                'options' =\n [\n                    'route' =\n '/',\n                    'defaults' =\n [\n                        'controller' =\n 'Application\\Controller\\IndexController',\n                        'action' =\n 'index',\n                    ],\n                ],\n            ],\n            // Literal route named \nblog\n, with child routes\n            'blog' =\n [\n                'type' =\n 'literal',\n                'options' =\n [\n                    'route' =\n '/blog',\n                    'defaults' =\n [\n                        'controller' =\n 'Application\\Controller\\BlogController',\n                        'action' =\n 'index',\n                    ],\n                ],\n                'may_terminate' =\n true,\n                'child_routes' =\n [\n                    // Segment route for viewing one blog post\n                    'post' =\n [\n                        'type' =\n 'segment',\n                        'options' =\n [\n                            'route' =\n '/[:slug]',\n                            'constraints' =\n [\n                                'slug' =\n '[a-zA-Z0-9_-]+',\n                            ],\n                            'defaults' =\n [\n                                'action' =\n 'view',\n                            ],\n                        ],\n                    ],\n                    // Literal route for viewing blog RSS feed\n                    'rss' =\n [\n                        'type' =\n 'literal',\n                        'options' =\n [\n                            'route' =\n '/rss',\n                            'defaults' =\n [\n                                'action' =\n 'rss',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\nWhen using child routes, naming of the routes follows the \nparent/child\n\npattern, so to use the child routes from the above example:\n\n\necho $this-\nurl('blog'); // gives \n/blog\n\necho $this-\nurl('blog/post', ['slug' =\n 'my-post']); // gives \n/blog/my-post\n\necho $this-\nurl('blog/rss'); // gives \n/blog/rss\n\n\n\n\nAn example with multiple Hostnames and subdomains within a single application\n\n\nreturn [\n    'router' =\n [\n        'routes' =\n [\n            'modules.zendframework.com' =\n [\n                'type' =\n 'Zend\\Mvc\\Router\\Http\\Hostname',\n                'options' =\n [\n                    'route' =\n ':4th.[:3rd.]:2nd.:1st', // domain levels from right to left\n                    'contraints' =\n [\n                        '4th' =\n 'modules',\n                        '3rd' =\n '.*?', // optional 3rd level domain such as .ci, .dev or .test\n                        '2nd' =\n 'zendframework',\n                        '1st' =\n 'com',\n                    ],\n                    // Purposely omit default controller and action\n                    // to let the child routes control the route match\n                ],\n                // child route controllers may span multiple modules as desired\n                'child_routes' =\n [\n                    'index' =\n [\n                        'type' =\n 'Zend\\Mvc\\Router\\Http\\Literal',\n                        'options' =\n [\n                            'route' =\n '/',\n                            'defaults' =\n [\n                                'controller' =\n 'Module\\Controller\\Index',\n                                'action' = \n 'index',\n                            ],\n                        ],\n                        'may_terminate' =\n true,\n                    ],\n                ],\n            ],\n            'packages.zendframework.com' =\n [\n                'type' =\n 'Zend\\Mvc\\Router\\Http\\Hostname',\n                'options' =\n [\n                    'route' =\n ':4th.[:3rd.]:2nd.:1st', // domain levels from right to left\n                    'contraints' =\n [\n                        '4th' =\n 'packages',\n                        '3rd' =\n '.*?', // optional 3rd level domain such as .ci, .dev or .test\n                        '2nd' =\n 'zendframework',\n                        '1st' =\n 'com',\n                    ],\n                    // Purposely omit default controller and action\n                    // to let the child routes control the route match\n                ],\n                // child route controllers may span multiple modules as desired\n                'child_routes' =\n [\n                    'index' =\n [\n                        'type' =\n 'Zend\\Mvc\\Router\\Http\\Literal',\n                        'options' =\n [\n                            'route' =\n '/',\n                            'defaults' =\n [\n                                'controller' =\n 'Package\\Controller\\Index',\n                                'action' = \n 'index',\n                            ],\n                        ],\n                        'may_terminate' =\n true,\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\nThe above would match the following:\n\n\n\n\nmodules.zendframework.com\n would dispatch the \nIndex\n controller's \nindex\n\n  action of the \nModule\n module.\n\n\nmodules.ci.zendframework.com\n would dispatch the \nIndex\n controller's \nindex\n\n  action of the \nModule\n module.\n\n\npackages.zendframework.com\n would dispatch the \nIndex\n controller's \nindex\n\n  action of the \nPackage\n module.\n\n\npackages.dev.zendframework.com\n would dispatch the \nIndex\n controller's\n  \nindex\n action of the \nPackage\n module.\n\n\n\n\nThe \nUrl\n controller plugin or view helper may be used to generate URLs\nfollowing the above example:\n\n\n// reuse the route matched parameters to generate URLs\necho $this-\nurl('modules.zendframework.com/index', [], [], true);\necho $this-\nurl('packages.zendframework.com/index', [], [], true);\n\n\n\n\n\n\nmay_terminate and child_routes placement\n\n\nWhen defining child routes pay attention that the \nmay_terminate\n and\n\nchild_routes\n definitions are in same level as the \noptions\n and \ntype\n\ndefinitions. A common pitfall is to have those two definitions nested in\n\noptions\n, which will not result in the desired routes.\n\n\n\n\nConsole Route Types\n\n\nzend-mvc also allows routing Console based applications; console routes are\nexplained in the \nzend-console routing documentation\n.",
            "title": "Routing"
        },
        {
            "location": "/routing/#routing",
            "text": "Routing is the act of matching a request to a given controller.  Typically, routing will examine the request URI, and attempt to match the URI\npath segment against provided constraints. If the constraints match, a set of\n\"matches\" are returned, one of which should be the controller name to execute.\nRouting can utilize other portions of the request URI or environment as well.\nFor example, the host or scheme, query parameters, headers, request method, and\nmore.  The base unit of routing is a  Route :  namespace Zend\\Mvc\\Router;\n\nuse Zend\\Stdlib\\RequestInterface as Request;\n\ninterface RouteInterface\n{\n    public static function factory(array $options = []);\n    public function match(Request $request);\n    public function assemble(array $params = [], array $options = []);\n}  A  Route  accepts a  Request , and determines if it matches. If so, it returns a RouteMatch  object:  namespace Zend\\Mvc\\Router;\n\nclass RouteMatch\n{\n    public function __construct(array $params);\n    public function setMatchedRouteName($name);\n    public function getMatchedRouteName();\n    public function setParam($name, $value);\n    public function getParams();\n    public function getParam($name, $default = null);\n}  Typically, when a  Route  matches, it will define one or more parameters. These\nare passed into the  RouteMatch , and objects may query the  RouteMatch  for\ntheir values.  $id = $routeMatch- getParam('id', false);\nif (! $id) {\n    throw new Exception('Required identifier is missing!');\n}\n$entity = $resource- get($id);  Usually you will have multiple routes you wish to test against. In order to\nfacilitate this, you will use a route aggregate, usually implementing RouteStack :  namespace Zend\\Mvc\\Router;\n\ninterface RouteStackInterface extends RouteInterface\n{\n    public function addRoute($name, $route, $priority = null);\n    public function addRoutes(array $routes);\n    public function removeRoute($name);\n    public function setRoutes(array $routes);\n}  Routes will be queried in a LIFO order, and hence the reason behind the name RouteStack . zend-mvc provides two implementations of this interface, SimpleRouteStack  and  TreeRouteStack . In each, you register routes either one\nat a time using  addRoute() , or in bulk using  addRoutes() .  // One at a time:\n$route = Literal::factory([\n    'route' =  '/foo',\n    'defaults' =  [\n        'controller' =  'foo-index',\n        'action'     =  'index',\n    ],\n]);\n$router- addRoute('foo', $route);\n\n// In bulk:\n$router- addRoutes([\n    // using already instantiated routes:\n    'foo' =  $route,\n\n    // providing configuration to allow lazy-loading routes:\n    'bar' =  [\n        'type' =  'literal',\n        'options' =  [\n            'route' =  '/bar',\n            'defaults' =  [\n                'controller' =  'bar-index',\n                'action'     =  'index',\n            ],\n        ],\n    ],\n]);",
            "title": "Routing"
        },
        {
            "location": "/routing/#router-types",
            "text": "Two routers are provided, the  SimpleRouteStack  and  TreeRouteStack . Each\nworks with the above interface, but utilize slightly different options and\nexecution paths. By default, the zend-mvc uses the  TreeRouteStack  as the\nrouter.",
            "title": "Router Types"
        },
        {
            "location": "/routing/#simpleroutestack",
            "text": "This router takes individual routes that provide their full matching logic in\none go, and loops through them in LIFO order until a match is found. As such,\nroutes that will match most often should be registered last, and least common\nroutes first. Additionally, you will need to ensure that routes that potentially\noverlap are registered such that the most specific match will match first (i.e.,\nregister later). Alternatively, you can set priorities by giving the priority as\nthird parameter to the  addRoute()  method, specifying the priority in the route\nspecifications or setting the priority property within a route instance before\nadding it to the route stack.",
            "title": "SimpleRouteStack"
        },
        {
            "location": "/routing/#treeroutestack",
            "text": "Zend\\Mvc\\Router\\Http\\TreeRouteStack  provides the ability to register trees of\nroutes, and uses a B-tree algorithm to match routes. As such, you register a\nsingle route with many children.  A  TreeRouteStack  will consist of the following configuration:   A base \"route\", which describes the base match needed, the root of the tree.  An optional  route_plugins , which is a configured\n   Zend\\Mvc\\Router\\RoutePluginManager  that can lazy-load routes.  The option  may_terminate , which hints to the router that no other segments\n  will follow it.  An optional  child_routes  array, which contains additional routes that stem\n  from the base \"route\" (i.e., build from it). Each child route can itself be a\n   TreeRouteStack  if desired; in fact, the  Part  route works exactly this way.   When a route matches against a  TreeRouteStack , the matched parameters from\neach segment of the tree will be returned.  A  TreeRouteStack  can be your sole route for your application, or describe\nparticular path segments of the application.  An example of a  TreeRouteStack  is provided in the documentation of the  Part \nroute.",
            "title": "TreeRouteStack"
        },
        {
            "location": "/routing/#http-route-types",
            "text": "zend-mvc ships with the following HTTP route types.",
            "title": "HTTP Route Types"
        },
        {
            "location": "/routing/#zend92mvc92router92http92hostname",
            "text": "The  Hostname  route attempts to match the hostname registered in the request\nagainst specific criteria. Typically, this will be in one of the following\nforms:   subdomain.domain.tld  :subdomain.domain.tld   In the above, the second route would return a \"subdomain\" key as part of the\nroute match.  For any given hostname segment, you may also provide a constraint. As an\nexample, if the \"subdomain\" segment needed to match only if it started with \"fw\"\nand contained exactly 2 digits following, the following route would be needed:  $route = Hostname::factory([\n    'route' =  ':subdomain.domain.tld',\n    'constraints' =  [\n        'subdomain' =  'fw\\d{2}',\n    ],\n]);  In the above example, only a \"subdomain\" key will be returned in the RouteMatch . If you wanted to also provide other information based on matching,\nor a default value to return for the subdomain, you need to also provide\ndefaults.  $route = Hostname::factory([\n    'route' =  ':subdomain.domain.tld',\n    'constraints' =  [\n        'subdomain' =  'fw\\d{2}',\n    ],\n    'defaults' =  [\n        'type' =  'json',\n    ],\n]);  When matched, the above will return two keys in the  RouteMatch , \"subdomain\"\nand \"type\".",
            "title": "Zend\\Mvc\\Router\\Http\\Hostname"
        },
        {
            "location": "/routing/#zend92mvc92router92http92literal",
            "text": "The  Literal  route is for doing exact matching of the URI path. Configuration\ntherefore is solely the path you want to match, and the \"defaults\", or\nparameters you want returned on a match.  $route = Literal::factory([\n    'route' =  '/foo',\n    'defaults' =  [\n        'controller' =  'Application\\Controller\\IndexController',\n        'action' =  'foo',\n    ],\n]);  The above route would match a path \"/foo\", and return the key \"action\" in the RouteMatch , with the value \"foo\".",
            "title": "Zend\\Mvc\\Router\\Http\\Literal"
        },
        {
            "location": "/routing/#zend92mvc92router92http92method",
            "text": "The  Method  route is used to match the HTTP method or 'verb' specified in the\nrequest (See RFC 2616 Sec. 5.1.1). It can optionally be configured to match\nagainst multiple methods by providing a comma-separated list of method tokens.  $route = Method::factory([\n    'verb' =  'post,put',\n    'defaults' =  [\n        'controller' =  'Application\\Controller\\IndexController',\n        'action' =  'form-submit',\n    ],\n]);  The above route would match an http \"POST\" or \"PUT\" request and return a RouteMatch  object containing a key \"action\" with a value of \"form-submit\".",
            "title": "Zend\\Mvc\\Router\\Http\\Method"
        },
        {
            "location": "/routing/#zend92mvc92router92http92part",
            "text": "A  Part  route allows crafting a tree of possible routes based on segments of\nthe URI path. It actually extends the  TreeRouteStack .  Part  routes are difficult to describe, so we'll simply provide a sample one\nhere.  $route = Part::factory([\n    'route' =  [\n        'type' =  'literal',\n        'options' =  [\n            'route' =  '/',\n            'defaults' =  [\n                'controller' =  'Application\\Controller\\IndexController',\n                'action' =  'index',\n            ],\n        ],\n    ],\n    'route_plugins' =  $routePlugins,\n    'may_terminate' =  true,\n    'child_routes' =  [\n        'blog' =  [\n            'type' =  'literal',\n            'options' =  [\n                'route' =  '/blog',\n                'defaults' =  [\n                    'controller' =  'Application\\Controller\\BlogController',\n                    'action' =  'index',\n                ],\n            ],\n            'may_terminate' =  true,\n            'child_routes' =  [\n                'rss' =  [\n                    'type' =  'literal',\n                    'options' =  [\n                        'route' =  '/rss',\n                        'defaults' =  [\n                            'action' =  'rss',\n                        ]\n                    ],\n                    'may_terminate' =  true,\n                    'child_routes' =  [\n                        'subrss' =  [\n                            'type' =  'literal',\n                            'options' =  [\n                                'route' =  '/sub',\n                                'defaults' =  [\n                                    'action' =  'subrss',\n                                ],\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n        'forum' =  [\n            'type' =  'literal',\n            'options' =  [\n                'route' =  'forum',\n                'defaults' =  [\n                    'controller' =  'Application\\Controller\\ForumController',\n                    'action' =  'index',\n                ],\n            ],\n        ],\n    ],\n]);  The above would match the following:   /  would load the \"Index\" controller, \"index\" action.  /blog  would load the \"Blog\" controller, \"index\" action.  /blog/rss  would load the \"Blog\" controller, \"rss\" action.  /blog/rss/sub  would load the \"Blog\" controller, \"subrss\" action.  /forum  would load the \"Forum\" controller, \"index\" action.   You may use any route type as a child route of a  Part  route.",
            "title": "Zend\\Mvc\\Router\\Http\\Part"
        },
        {
            "location": "/routing/#part-routes-are-an-implementation-detail",
            "text": "Part  routes are not meant to be used directly. When you add definitions for child_routes  to any route type, that route will become a  Part  route. As\nalready said, describing  Part  routes with words is difficult, so hopefully\nthe additional  examples at the end  will provide\nfurther insight.",
            "title": "Part routes are an implementation detail"
        },
        {
            "location": "/routing/#route-plugins",
            "text": "In the above example, the  $routePlugins  is an instance of Zend\\Mvc\\Router\\RoutePluginManager , containing essentially the following\nconfiguration:  $routePlugins = new Zend\\Mvc\\Router\\RoutePluginManager();\n$plugins = [\n    'hostname' =  'Zend\\Mvc\\Router\\Http\\Hostname',\n    'literal'  =  'Zend\\Mvc\\Router\\Http\\Literal',\n    'part'     =  'Zend\\Mvc\\Router\\Http\\Part',\n    'regex'    =  'Zend\\Mvc\\Router\\Http\\Regex',\n    'scheme'   =  'Zend\\Mvc\\Router\\Http\\Scheme',\n    'segment'  =  'Zend\\Mvc\\Router\\Http\\Segment',\n    'wildcard' =  'Zend\\Mvc\\Router\\Http\\Wildcard',\n    'query'    =  'Zend\\Mvc\\Router\\Http\\Query',\n    'method'   =  'Zend\\Mvc\\Router\\Http\\Method',\n];\nforeach ($plugins as $name =  $class) {\n    $routePlugins- setInvokableClass($name, $class);\n}  When using  Zend\\Mvc\\Router\\Http\\TreeRouteStack , the  RoutePluginManager  is\nset up by default, and the developer does not need to worry about autoloading\nof standard HTTP routes.",
            "title": "Route plugins"
        },
        {
            "location": "/routing/#zend92mvc92router92http92regex",
            "text": "A  Regex  route utilizes a regular expression to match against the URI path. Any\nvalid regular expression is allowed; our recommendation is to use named captures\nfor any values you want to return in the  RouteMatch .  Since regular expression routes are often complex, you must specify a \"spec\" or\nspecification to use when assembling URLs from regex routes. The spec is simply\na string; replacements are identified using  %keyname%  within the string, with\nthe keys coming from either the captured values or named parameters passed to\nthe  assemble()  method.  Just like other routes, the  Regex  route can accept \"defaults\", parameters to\ninclude in the  RouteMatch  when successfully matched.  $route = Regex::factory([\n    'regex' =  '/blog/(? id [a-zA-Z0-9_-]+)(\\.(? format (json|html|xml|rss)))?',\n    'defaults' =  [\n        'controller' =  'Application\\Controller\\BlogController',\n        'action'     =  'view',\n        'format'     =  'html',\n    ],\n    'spec' =  '/blog/%id%.%format%',\n]);  The above would match  /blog/001-some-blog_slug-here.html , and return four\nitems in the  RouteMatch , an \"id\", the \"controller\", the \"action\", and the\n\"format\". When assembling a URL from this route, the \"id\" and \"format\" values\nwould be used to fill the specification.",
            "title": "Zend\\Mvc\\Router\\Http\\Regex"
        },
        {
            "location": "/routing/#zend92mvc92router92http92scheme",
            "text": "The  Scheme  route matches the URI scheme only, and must be an exact match. As\nsuch, this route, like the  Literal  route, simply takes what you want to match\nand the \"defaults\", parameters to return on a match.  $route = Scheme::factory([\n    'scheme' =  'https',\n    'defaults' =  [\n        'https' =  true,\n    ],\n]);  The above route would match the \"https\" scheme, and return the key \"https\" in\nthe  RouteMatch  with a boolean  true  value.",
            "title": "Zend\\Mvc\\Router\\Http\\Scheme"
        },
        {
            "location": "/routing/#zend92mvc92router92http92segment",
            "text": "A  Segment  route allows matching any segment of a URI path. Segments are\ndenoted using a colon, followed by alphanumeric characters; if a segment is\noptional, it should be surrounded by brackets.  As an example,  /:foo[/:bar] \nwould match a  /  followed by text and assign it to the key \"foo\"; if any\nadditional  /  characters are found, any text following the last one will be\nassigned to the key \"bar\".  The separation between literal and named segments can be anything. For example,\nthe above could be done as  /:foo{-}[-:bar]  as well. The  {-}  after the  :foo \nparameter indicates a set of one or more delimiters, after which matching of the\nparameter itself ends.  Each segment may have constraints associated with it. Each constraint should\nsimply be a regular expression expressing the conditions under which that\nsegment should match.  Also, as you can in other routes, you may provide defaults to use; these are\nparticularly useful when using optional segments.  As a complex example:  $route = Segment::factory([\n    'route' =  '/:controller[/:action]',\n    'constraints' =  [\n        'controller' =  '[a-zA-Z][a-zA-Z0-9_-]+',\n        'action'     =  '[a-zA-Z][a-zA-Z0-9_-]+',\n    ],\n    'defaults' =  [\n        'controller' =  'Application\\Controller\\IndexController',\n        'action'     =  'index',\n    ],\n]);",
            "title": "Zend\\Mvc\\Router\\Http\\Segment"
        },
        {
            "location": "/routing/#zend92mvc92router92http92query-deprecated",
            "text": "",
            "title": "Zend\\Mvc\\Router\\Http\\Query (Deprecated)"
        },
        {
            "location": "/routing/#potential-security-issue",
            "text": "Misuse of this route can lead to potential security issues.",
            "title": "Potential security issue"
        },
        {
            "location": "/routing/#deprecated",
            "text": "This route part is deprecated since you can now add query parameters without a\nquery route.   The  Query  route part allows you to specify and capture query string parameters\nfor a given route.  The intention of the  Query  part is that you do not instantiate it in its own\nright, but use it as a child of another route part.  An example of its usage would be:  $route = Part::factory([\n    'route' =  [\n        'type'    =  'literal',\n        'options' =  [\n            'route'    =  'page',\n            'defaults' =  [],\n        ],\n    ],\n    'may_terminate' =  true,\n    'route_plugins' =  $routePlugins,\n    'child_routes'  =  [\n        'query' =  [\n            'type' =  'Query',\n            'options' =  [\n                'defaults' =  [\n                    'foo' =  'bar',\n                ],\n            ],\n        ],\n    ],\n]);  This then allows you to create query strings using the url view helper.  $this- url(\n    'page/query',\n    [\n        'name'   =  'my-test-page',\n        'format' =  'rss',\n        'limit'  =  10,\n    ]\n);  Per the above example, you must add  /query  (the name we gave to our query\nroute segment) to your route name in order to append a query string. If you do\nnot specify  /query  in the route name, then no query string will be appended.  Our example \"page\" route has only one defined parameter of \"name\"\n( /page[/:name] ), meaning that the remaining parameters of \"format\" and \"limit\"\nwill then be appended as a query string.  The output from our example should then be /page/my-test-page?format=rss limit=10",
            "title": "Deprecated"
        },
        {
            "location": "/routing/#zend92mvc92router92http92wildcard-deprecated",
            "text": "",
            "title": "Zend\\Mvc\\Router\\Http\\Wildcard (Deprecated)"
        },
        {
            "location": "/routing/#potential-security-issue_1",
            "text": "Misuse of this route type can lead to potential security issues.",
            "title": "Potential security issue"
        },
        {
            "location": "/routing/#deprecated_1",
            "text": "This route type is deprecated. Use the  Segment  route type.   The  Wildcard  route type matches all remaining segments of a URI path.",
            "title": "Deprecated"
        },
        {
            "location": "/routing/#http-routing-examples",
            "text": "Most of the routing definitions will be done in module configuration files, so\nthe following examples will show how to set up routes in config files.",
            "title": "HTTP Routing Examples"
        },
        {
            "location": "/routing/#simple-example-with-two-literal-routes",
            "text": "return [\n    'router' =  [\n        'routes' =  [\n            // Literal route named  home \n            'home' =  [\n                'type' =  'literal',\n                'options' =  [\n                    'route' =  '/',\n                    'defaults' =  [\n                        'controller' =  'Application\\Controller\\IndexController',\n                        'action' =  'index',\n                    ],\n                ],\n            ],\n            // Literal route named  contact \n            'contact' =  [\n                'type' =  'literal',\n                'options' =  [\n                    'route' =  'contact',\n                    'defaults' =  [\n                        'controller' =  'Application\\Controller\\ContactController',\n                        'action' =  'form',\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Simple example with two literal routes"
        },
        {
            "location": "/routing/#a-complex-example-with-child-routes",
            "text": "return [\n    'router' =  [\n        'routes' =  [\n            // Literal route named  home \n            'home' =  [\n                'type' =  'literal',\n                'options' =  [\n                    'route' =  '/',\n                    'defaults' =  [\n                        'controller' =  'Application\\Controller\\IndexController',\n                        'action' =  'index',\n                    ],\n                ],\n            ],\n            // Literal route named  blog , with child routes\n            'blog' =  [\n                'type' =  'literal',\n                'options' =  [\n                    'route' =  '/blog',\n                    'defaults' =  [\n                        'controller' =  'Application\\Controller\\BlogController',\n                        'action' =  'index',\n                    ],\n                ],\n                'may_terminate' =  true,\n                'child_routes' =  [\n                    // Segment route for viewing one blog post\n                    'post' =  [\n                        'type' =  'segment',\n                        'options' =  [\n                            'route' =  '/[:slug]',\n                            'constraints' =  [\n                                'slug' =  '[a-zA-Z0-9_-]+',\n                            ],\n                            'defaults' =  [\n                                'action' =  'view',\n                            ],\n                        ],\n                    ],\n                    // Literal route for viewing blog RSS feed\n                    'rss' =  [\n                        'type' =  'literal',\n                        'options' =  [\n                            'route' =  '/rss',\n                            'defaults' =  [\n                                'action' =  'rss',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];  When using child routes, naming of the routes follows the  parent/child \npattern, so to use the child routes from the above example:  echo $this- url('blog'); // gives  /blog \necho $this- url('blog/post', ['slug' =  'my-post']); // gives  /blog/my-post \necho $this- url('blog/rss'); // gives  /blog/rss",
            "title": "A complex example with child routes"
        },
        {
            "location": "/routing/#an-example-with-multiple-hostnames-and-subdomains-within-a-single-application",
            "text": "return [\n    'router' =  [\n        'routes' =  [\n            'modules.zendframework.com' =  [\n                'type' =  'Zend\\Mvc\\Router\\Http\\Hostname',\n                'options' =  [\n                    'route' =  ':4th.[:3rd.]:2nd.:1st', // domain levels from right to left\n                    'contraints' =  [\n                        '4th' =  'modules',\n                        '3rd' =  '.*?', // optional 3rd level domain such as .ci, .dev or .test\n                        '2nd' =  'zendframework',\n                        '1st' =  'com',\n                    ],\n                    // Purposely omit default controller and action\n                    // to let the child routes control the route match\n                ],\n                // child route controllers may span multiple modules as desired\n                'child_routes' =  [\n                    'index' =  [\n                        'type' =  'Zend\\Mvc\\Router\\Http\\Literal',\n                        'options' =  [\n                            'route' =  '/',\n                            'defaults' =  [\n                                'controller' =  'Module\\Controller\\Index',\n                                'action' =   'index',\n                            ],\n                        ],\n                        'may_terminate' =  true,\n                    ],\n                ],\n            ],\n            'packages.zendframework.com' =  [\n                'type' =  'Zend\\Mvc\\Router\\Http\\Hostname',\n                'options' =  [\n                    'route' =  ':4th.[:3rd.]:2nd.:1st', // domain levels from right to left\n                    'contraints' =  [\n                        '4th' =  'packages',\n                        '3rd' =  '.*?', // optional 3rd level domain such as .ci, .dev or .test\n                        '2nd' =  'zendframework',\n                        '1st' =  'com',\n                    ],\n                    // Purposely omit default controller and action\n                    // to let the child routes control the route match\n                ],\n                // child route controllers may span multiple modules as desired\n                'child_routes' =  [\n                    'index' =  [\n                        'type' =  'Zend\\Mvc\\Router\\Http\\Literal',\n                        'options' =  [\n                            'route' =  '/',\n                            'defaults' =  [\n                                'controller' =  'Package\\Controller\\Index',\n                                'action' =   'index',\n                            ],\n                        ],\n                        'may_terminate' =  true,\n                    ],\n                ],\n            ],\n        ],\n    ],\n];  The above would match the following:   modules.zendframework.com  would dispatch the  Index  controller's  index \n  action of the  Module  module.  modules.ci.zendframework.com  would dispatch the  Index  controller's  index \n  action of the  Module  module.  packages.zendframework.com  would dispatch the  Index  controller's  index \n  action of the  Package  module.  packages.dev.zendframework.com  would dispatch the  Index  controller's\n   index  action of the  Package  module.   The  Url  controller plugin or view helper may be used to generate URLs\nfollowing the above example:  // reuse the route matched parameters to generate URLs\necho $this- url('modules.zendframework.com/index', [], [], true);\necho $this- url('packages.zendframework.com/index', [], [], true);",
            "title": "An example with multiple Hostnames and subdomains within a single application"
        },
        {
            "location": "/routing/#may_terminate-and-child_routes-placement",
            "text": "When defining child routes pay attention that the  may_terminate  and child_routes  definitions are in same level as the  options  and  type \ndefinitions. A common pitfall is to have those two definitions nested in options , which will not result in the desired routes.",
            "title": "may_terminate and child_routes placement"
        },
        {
            "location": "/routing/#console-route-types",
            "text": "zend-mvc also allows routing Console based applications; console routes are\nexplained in the  zend-console routing documentation .",
            "title": "Console Route Types"
        }
    ]
}